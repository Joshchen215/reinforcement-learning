import numpy as np
import matplotlib.pyplot as plt
from src.core.Enum.Action import Action


class GridWorld:
    """网格世界环境类"""
    def __init__(self, grid, start, end, target_reward, boundary_reward, forbidden_reward, random_start):
        """

        :param grid: 2D 列表或数组，非负值为正常格，-1 为障碍
        :param start: 起始位置 (row, col)
        :param end: 终点位置
        :param target_reward: 到达终点的奖励
        :param boundary_reward: 碰撞墙体惩罚
        :param forbidden_reward: 进入禁行区域的惩罚
        :param random_start: 是否随机起点
        """
        self.grid = np.array(grid)
        self.start = np.array(start)
        self.end = np.array(end)
        self.target_reward = target_reward
        self.boundary_reward = boundary_reward
        self.forbidden_reward = forbidden_reward
        self.random_start = random_start
        self.current = self.start
        self.reset()

    def reset(self):
        """重置开始状态"""
        if self.random_start:
            start_row = np.random.randint(0, self.grid.shape[0])
            start_col = np.random.randint(0, self.grid.shape[1])
            # 随机选择非禁行状态以及终止状态的网格作为起点
            while self.grid[start_row, start_col] == -1 and np.array(start_row, start_col) != self.end:
                start_row = np.random.randint(0, self.grid.shape[0])
                start_col = np.random.randint(0, self.grid.shape[1])
            self.start = np.array(start_row, start_col)
        else:
            self.start = np.array(self.start)
        # 重置当前状态为开始状态
        self.current = self.start

    def current2State_ind(self):
        """返回当前状态编号"""
        row, col = self.current
        return row * self.grid.shape[1] + col + 1

    def step(self, action: Action):
        """执行动作，返回 (next_state, reward, done)"""
        row, col = self.current
        # 计算新坐标
        if action == Action.UP:
            new_row, new_col = row - 1, col
        elif action == Action.RIGHT:
            new_row, new_col = row, col + 1
        elif action == Action.DOWN:
            new_row, new_col = row + 1, col
        elif action == Action.LEFT:
            new_row, new_col = row, col - 1
        else:
            raise ValueError(f"未知动作: {action}")

        # 判断新坐标是否合法
        # 撞墙
        if new_row < 0 or new_row >= self.grid.shape[0] or new_col < 0 or new_col >= self.grid.shape[1]:
            reward = self.boundary_reward
            new_row, new_col = row, col
        # 普通空格
        elif np.array(new_row-1, new_col-1) != self.end:
            reward = 0.0
        # 终止状态
        else:
            reward = self.target_reward

        self.current = (new_row, new_col)
        return self.current2State_ind(), reward

    def plot_state_values(self, state_values, value_format="{:.1f}", plot_title=None):
        """
        可视化状态值函数
        Args:
            state_values: (总状态数,)数组，每个状态的值
            value_format: 数值格式
            plot_title: 图表标题
        """
        plt.figure(figsize=(5, 5), dpi=200)
        # 用不同灰度表示墙壁和目标状态
        plt.imshow((self._grid_padded <= -1) + (self._grid_padded > 0) * 0.5, cmap='Greys', vmin=0, vmax=1)
        ax = plt.gca()
        ax.grid(False)
        plt.xticks([])
        plt.yticks([])

        if plot_title:
            plt.title(plot_title)

        # 在非终止状态位置显示状态值
        for (int_obs, state_value) in enumerate(state_values):
            y, x = self.int_to_state(int_obs)
            if (y, x) in self._non_term_states:
                plt.text(x + 1, y + 1, value_format.format(state_value), ha='center', va='center')

        # 绘制网格线
        h, w = self._grid_padded.shape
        for y in range(h - 1):
            plt.plot([-0.5, w - 0.5], [y + 0.5, y + 0.5], '-k', lw=2)
        for x in range(w - 1):
            plt.plot([x + 0.5, x + 0.5], [-0.5, h - 0.5], '-k', lw=2)

    def plot_policy(self, policy, plot_title=None):
        """
        可视化策略
        Args:
            policy: (总状态数,)数组，每个状态的动作(0-3)
            plot_title: 图表标题
        """
        # 动作符号映射
        action_names = [r"$\uparrow$", r"$\rightarrow$", r"$\downarrow$", r"$\leftarrow$"]
        plt.figure(figsize=(5, 5), dpi=200)
        plt.imshow((self._grid_padded <= -1) + (self._grid_padded > 0) * 0.5, cmap='Greys', vmin=0, vmax=1)
        ax = plt.gca()
        ax.grid(False)
        plt.xticks([])
        plt.yticks([])

        if plot_title:
            plt.title(plot_title)

        # 在非终止状态位置显示动作方向
        for (int_obs, action) in enumerate(policy):
            y, x = self.int_to_state(int_obs)
            if (y, x) in self._non_term_states:
                action_arrow = action_names[action]
                plt.text(x + 1, y + 1, action_arrow, ha='center', va='center')
